---
layout: page
title: "SCSI和SATA的稳定性"
date: 2008-02-12 09:35
comments: true
sharing: true
footer: true
---

最近看到<a href="http://permabit.wordpress.com/2008/08/20/are-fibre-channel-and-scsi-drives-more-reliable/" target="_blank">一篇文章</a>讨论SATA和SCSI硬盘的可靠性问题。这篇文章的结论是：两种硬盘的故障率（<a href="http://en.wikipedia.org/wiki/MTBF" target="_blank">MTBF</a>）是极其接近的，只不过便宜的SATA硬盘要比昂贵的SCSI硬盘的**误码率（<a href="http://en.wikipedia.org/wiki/Bit_error_ratio" target="_blank">BER</a>）要高得多。**也就是说，出现某个sector无法读取的情况，SATA要比SCSI严重得多。按照他的计算，一个1TB的硬盘，通常你无法读取所有sector的概率达到了56%，因此你在出现硬盘故障的情况下重建RAID的希望是：**无法实现**。 

的确如此，在过去，一般RAID的磁盘容量都不大，比如20GB，无法恢复一个RAID的概率按照文献是1.1% [^1]。 
当硬盘容量上升到200GB，假设出现故障的概率是线性增长的 [^2]
，那么失败率就会有11%：估计负责存储的人就会被老板操的厉害了。 


硬盘故障
-------

一般不是很注意用磁盘工具看自己硬盘坏道的同学对IDE接口的硬盘有这样的概念：这个硬盘要么就一帆风顺的工作着，要么就是怎么修复也已经治不好的。也就是说如果硬盘挂几个sector如果你不注意其实根本感觉不到，一定是0道挂了才知道自己中招了。

这种体验其实是因为现在的硬盘都有[spare sector remapping][1]技术，可以自动检测出一般的坏道，然后停止使用它们。但是这项技术的缺陷是，必须在“写”操作的时候，才能进行检测：你往里面写东西完毕后，会立刻读取出来进行校验，如果校验失败，就会写到冗余的磁道去，并停止使用当前坏道。但是当你读取内容时，校验失败呢？ 


误码率
-------


读取内容时出错的概率就是“误码率”描述的问题。现代硬盘可以保证你写进去的东西马上再读的时候是没有问题的，但是数据还是可以在某年某月某日的读取中丢失。这种事情的概率（per bit）从来没有随着硬盘技术的进步降低：因为SCSI硬盘的容量一般比过去的SATA硬盘要大很多。

但是开头提到的那篇文章里面说有56%，这个数据还是显得有些“不可信”。大概是因为下面两个原因，我们才没有怎么听说过这么高的BER吧。 

首先，我们自己用的硬盘都不会跑RAID。虽然现在我们自己的硬盘容量也变得很大（本座有个500G的移动硬盘拿来放电影和音乐），但是这个量级的硬盘上面大多数数据你都很少去读取它。因此从概率上讲，坏道出现在那些没卵味的电影和音乐上的可能性大很多，而**大多数电影和音乐都没卵味**。 

但是对于跑RAID的用户，对整个硬盘进行读取的事情经常发生。即使系统足够和谐，知道不向你报告那些出现在你从不读取的文件中的坏道，但是也只是略过了报告这一步：它还是会找到所有的坏道，56%就来了。 

其次，虽然你丢了一些sector，一般情况下也没啥关系。还是以电影和音乐为例，大多数的压缩算法都从设计上允许有一些这样或者那样的误码。丢了几个sector的数据，也许对你来说就是松岛枫身上的马赛克变厚了一些而已，你都不知道是硬盘作祟。 


怎么办
-------


如果你的硬盘里面放了重要的东西，你又没有跑RAID，出现了错误数据怎么恢复？本座好像还没有听说过可以直接化解这种问题的办法，所以大概定期的增量备份是不可缺少的：备份，备份，备份！ 

而在RAID上面的话，问题就要简单一些：你只需要在硬盘故障之前找出坏道。最好每个星期，你都对所有的sector内容进行一次读取。如果你的RAID是好的，但是检测出了坏道，你就可以先用RAID将坏道的内容重建出来，然后再写到有问题的硬盘里面去：这个时候前面说的sector remapping代码就会把坏的sector永远屏蔽了。 

这种读取-重建的代码从来没有开放过，你必须自己编码才能实现。不过，我们有<a href="http://linux.die.net/man/1/ionice" target="_blank">ionice</a>可以调用，实现起来不会太难。 

还有一个关键问题就是你要确定你的RAID软件支持在个别坏道被发现时能够恢复。比如Linux 2.4的RAID代码就和我们过去的假设一样：一个硬盘挂了，它就是无法恢复的彻底挂了。于是这个硬盘被立刻移出RAID，直到你换一个新的硬盘。问题是现代的硬盘容量如此之大，每个硬盘都可能会有坏道，于是根据这种假设去重建RAID变得没有可能。而且，扔掉一个磁盘是做存储的人最不想听到的结果：你连恢复它的可能性都没有了。 

[1]: http://en.wikipedia.org/wiki/Bad_sector

[^1]: 注意，1.1%已经很不错了，因为你在硬盘故障之后，才需要去恢复RAID。两个概率是要相乘的，如果你知道本座在说什么的话
[^2]: 当然，线性增长的这个假设是错误的。我们可以做一个计算：1TB的故障率是56%的话，无故障率是1-0.56=0.44。把一个1TB硬盘划成50X20GB的数据块。整个硬盘无故障也就是每个 数据块没故障，因此每个数据块无故障率应该是0.44的50次方根，大概是98.4%。那20GB的故障率大概是1-98.4%=1.6%左右，而不是1.1%。