<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tips | @Lenciel]]></title>
  <link href="http://lenciel.com/categories/tips/atom.xml" rel="self"/>
  <link href="http://lenciel.com/"/>
  <updated>2017-05-02T17:08:47+08:00</updated>
  <id>http://lenciel.com/</id>
  <author>
    <name><![CDATA[Lenciel]]></name>
    <email><![CDATA[lenciel@gmail.com]]></email>
  </author>

  
  <entry>
    <title type="html"><![CDATA[如何解决苹果的邮件Spam]]></title>
    <link href="http://lenciel.com/2016/11/how-to-resolve-apple-calendar-spam/"/>
    <updated>2016-11-30T22:28:40+08:00</updated>
    <id>http://lenciel.com/2016/11/how-to-resolve-apple-calendar-spam</id>
    <content type="html"><![CDATA[<p>从10月的某一天开始，我发现我的日历每天都充满了外部邀请：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/20292-5d2a6a90f697fcab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Oh Shoot" /></p>

<p>很显然，天朝的某些人拿到了一个超大的邮件地址列表，然后在发送事件邀请：Mac会把这种邀请显示在日历上面，然后显示一个通知。</p>

<p>按说大数据时代了，Apple是可以想办法来解决一下这么猖狂的Spam的，但是一个多月过去了，什么都没有发生，我收到的邀请也越来越多了，只能自己解决一下。</p>

<a name="L....................."></a>
<h3>拒绝是没有用的</h3>

<p>和别的日历上收到事件邀请（类似于工作中收到会议邀请之类）一样，按直觉你的处理方式就是点开这个事件，然后点击“拒绝参加”或者“拒绝参加这个系列”。</p>

<p>但这样其实是没有用的，甚至是有害的。因为对方是要Spam你而不是真要问你要不要参加什么事情。你一旦“拒绝”，对方就知道你在他拿到的邮件列表里面是个“有效对象”，奇奇怪怪的邀请很快就会源源不断地发过来塞满你的日历。</p>

<a name="L............"></a>
<h3>处理方法</h3>

<p>在stackexchange上有个关于如何处理的<a href="http://apple.stackexchange.com/questions/258424/spam-icloud-calendar-invitation/">讨论</a>，因为这个网站会闪断并且进去看的里面是怎么说中国人的也很刺激，所以我就稍微演示一下：</p>

<p>首先登录<a href="https://www.icloud.com">icloud网站</a>，然后进入calendar，点击<code>Edit</code>然后新建一个日历，比如<code>Spam</code>：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/20292-9d6643b09baec11f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建日历" /></p>

<p>然后点击某个你想删除的邀请，把它归档到这个新建的日历里面，要点右上角进入这个操作的入口：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/20292-addf2b77d0760b4c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归档邀请" /></p>

<p>最后，删除这个新建的日历，这个系列的邀请就被清理干净了。</p>

<a name="L............"></a>
<h3>连根拔起</h3>

<p>但是这样能清静多久完全取决于你在攻击者心中的权重，如果来一串邀请就这么操作一遍，心情也是很差的，所以你可以直接把所有的邀请都设置成通过邮件来通知：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/20292-a2a0d0c09520b3e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一步：进入设置" /></p>

<p><img src="http://upload-images.jianshu.io/upload_images/20292-702275e3ee3966cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二步：进入高级选项" /></p>

<p><img src="http://upload-images.jianshu.io/upload_images/20292-72790afa08ac2789.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三步：勾选通过邮件通知" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电脑视觉综合症]]></title>
    <link href="http://lenciel.com/2016/09/computer-vision-syndrome/"/>
    <updated>2016-09-30T13:49:17+08:00</updated>
    <id>http://lenciel.com/2016/09/computer-vision-syndrome</id>
    <content type="html"><![CDATA[<p><img src="/downloads/images/2016_09/computer.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>虽然叫做“<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E8%A7%86%E8%A7%89%E7%BB%BC%E5%90%88%E7%97%87">电脑视觉综合症(Computer Vision Syndrome)</a>”，但真正成为祸害，却是在智能手机一统天下之后：据美帝医生的统计，已经有八千万左右的患者。</p>

<p>的确，人类历史上还从来没有过现在这样，需要每天长时间盯着几十厘米远的一块屏幕的阶段，而根据医生的数据，只要每天超过3个小时的人，有90%都会有电脑视觉综合症的症状。</p>

<p>微信的产品经理说，每个人每天花在微信里面的时间平均下来4个小时左右。</p>

<p>So, everybody is on the boat&hellip;</p>

<a name="Why"></a>
<h3>Why</h3>

<p>根据<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E8%A7%86%E8%A7%89%E7%BB%BC%E5%90%88%E7%97%87">维基百科</a>：</p>

<p><blockquote><p>眼睛里有一条肌肉，让眼睛可以把焦点对准你正在看的东西。电脑和手机屏幕通常要比书亮，所以我们把它们放得离我们的眼睛比书要远。假如你持续盯着电脑屏幕看几个小时，过度盯视就会使得这条肌肉疲劳，也会使眼球表面干燥。</p></p><p><p>这种病症会导致疲劳、头疼、颈部疼痛、视觉重影，以及间歇性视觉模糊，使得成年人工作效率降低，导致学校儿童学习障碍，成绩下降。</p></blockquote></p>

<a name="So."></a>
<h3>So?</h3>

<p>研究生才开始编程的本座，因为一开始发力过猛，造成这十年受了很多身体上的惩罚。</p>

<p>久病成医，对各种RSI创伤也有了心得：在知乎上<a href="https://www.zhihu.com/question/20721016/answer/15963670?group_id=763467842120056832">唯一的贡献</a>就是这方面的。</p>

<p>从理论上讲，要保护眼睛，是有一些比较简单的办法。比如使用滴眼液，改变眼干的症状。再比如“20-20-20”法则：每过20分钟，就把手放在大概20公分远的地方，看着它眨20下眼睛。</p>

<p>但，就像每个程序员一样，你可能正在无法被中断的工作状态里面，没有工具的帮助，要操作“20-20-20”，略不现实。</p>

<a name="Tools"></a>
<h3>Tools</h3>

<p>首先，听我的，赶紧装一个<a href="https://justgetflux.com/">flux</a>。它的具体的原理可以看<a href="https://justgetflux.com/research.html">它的网站</a>，但简单来说，它会根据你工作环境的背景光线强度，自动计算并调整屏幕色温来保护你眼睛：Apple借鉴flux，在iOS 9.3版本开始，提供了<a href="http://apple.zol.com.cn/563/5630879.html">夜间模式</a>。</p>

<p>需要注意的是，flux也好，夜间模式也好，没习惯之前，你会觉得它们偏黄。</p>

<p>然后，你需要一个中断自己的机制：</p>

<ul>
<li><a href="https://itunes.apple.com/us/app/breaktime/id427475982?mt=12&amp;at=1l3vuLL&amp;ct=ln">Breaktime</a> (Mac和iOS)</li>
<li><a href="https://itunes.apple.com/us/app/eye-care-eye-break-reminder/id1080053304?mt=12&amp;at=1l3vuLL&amp;ct=ln">Eye Care </a>(Mac)</li>
<li><a href="https://itunes.apple.com/us/app/pomodoro-time-focus-timer/id973134470?mt=12&amp;at=1l3vuLL&amp;ct=ln">Pomodoro Time</a> (Mac)</li>
<li><a href="http://eyeleo.com/">EyeLeo</a> (Windows)</li>
<li><a href="https://sourceforge.net/projects/eyeprov2/">Eye Pro</a> (Windows)</li>
</ul>


<p> 我自己是用<a href="https://itunes.apple.com/us/app/be-focused-pro-focus-timer/id961632517?mt=12">Pomodoro Time Pro</a>，但它其实主要是一个提高效率的软件，在提醒你保护眼睛方面功能比较弱。而列表里面别的一些软件这方面要更强，比如大多数都支持锁定屏幕强制休息，有些比如Eye Pro还会有保健知识等等。</p>

<p>当然，什么工具适合都是因人而异的，用自己的意志力或者闹钟之类的，理论上也能达到一样的目的：不过我已经说了，对干我们这行的来说，基本无效。</p>

<p>比如我自己就发现，如果是晚上通宵干活的话，那么我最好是站着。因为夜深人静，自己进入了工作的状态，会把所有的中断都屏蔽掉，也不会开着计时器。不但不会想起来休息眼睛，喝水都懒得去喝。</p>

<p>这个时候，伤害有多大，就看能站多久了&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Chrome自定义搜索引擎快速查找资源]]></title>
    <link href="http://lenciel.com/2016/02/how-can-everybody-use-chrome/"/>
    <updated>2016-02-20T11:53:34+08:00</updated>
    <id>http://lenciel.com/2016/02/how-can-everybody-use-chrome</id>
    <content type="html"><![CDATA[<p>这篇文章讨论的办法，主要是结合使用<code>带参数Google搜索</code>+<code>Chrome快捷搜索入口</code>，鉴于众所周知的原因，如果你不会翻墙可能不能直接使用。</p>

<p>但是鉴于国内搜索引擎功能上多少都有借鉴Google，浏览器多少都有借鉴Chrome，所以这里讨论的办法也许用其他"搜索"+&ldquo;浏览器"组合也可以使用。只是我们都知道国内搜索引擎索引出来的结果有多离奇，所以效果上可能会打一些折扣。</p>

<a name="L.........Google......"></a>
<h3>带参数Google搜索</h3>

<p>Google可以带参数搜索一般用户可能不太用到，但其实对找东西很有用。完整的说明可以自己找来看，对普通用户也非常有用的有：</p>

<a name="L........."></a>
<h4>双引号</h4>

<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</p>

<p>比如搜索代码里面的抛出的错误，你直接把错误行扔进去，往往不如加上引号来完全匹配准确。</p>

<a name="filetype"></a>
<h4>filetype</h4>

<p>用于搜索特定文件格式，比如搜索<code>filetype:pdf</code>，那么就只返回所有包含关键词的pdf文件。</p>

<a name="site"></a>
<h4>site</h4>

<p>用来搜索某个域名下的所有文件，比如在百度网盘里面搜索名字包含Hadoop的文件，就可以搜索<code>Hadoop site:pan.baidu.com</code>。</p>

<a name="L......"></a>
<h4>减号</h4>

<p>代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面紧跟着需要排除的词。</p>

<p>熟练掌握并且综合使用上面这些语法，你就可以非常快速地找到你需要的东西了。</p>

<a name="Chrome.................."></a>
<h3>Chrome快捷搜索入口</h3>

<p>Chrome为你提供了快捷方式来使用搜索。<code>Cmd+L</code>（Windows平台大概是<code>Ctrl+L</code>）进入地址栏，然后输入要搜索的内容，回车，就会使用你的默认搜索引擎进行搜索。</p>

<p>假如你要切换一个搜索引擎，比如你的默认引擎是Google，偶尔你需要用百度来搜索，只需要在地址栏里面先敲<code>baidu</code>，然后按<code>Tab</code>键，然后输入你需要搜索的关键字并回车，就可以了。</p>

<p>Chrome里面你可以这样使用的搜索引擎数量其实是远超你想象的。</p>

<p>在地址栏里面敲入<code>chrome://settings/</code>，然后进入搜索引擎的配置你就可以看到它们：</p>

<p><img src="/downloads/images/2016_02/manage_search_engine.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<a name="L................................."></a>
<h3>创建使用自定义搜索引擎</h3>

<p>一旦开始使用自定义搜索，你就会发现有些搜索使用频率相当高。</p>

<p>比如在百度盘里面搜索某个文件。</p>

<p>再比如在<a href="http://quora.com/">Quora</a>或者<a href="http://zhihu.com">知乎</a>里面搜索包含某个关键字的问答。</p>

<p>这个时候你只需要在搜索引擎列表的末尾添加一个自定义项：</p>

<p><img src="/downloads/images/2016_02/custom_search_engine.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>比如我们添加一个<code>Keyword</code>是<code>panb</code>的搜索引擎，它的URL是：</p>

<pre><code>https://www.google.com.hk/search?q=%s+site%3Apan.baidu.com
</code></pre>

<p>注意URL这个参数需要做<a href="https://docs.oracle.com/javase/7/docs/api/java/net/URLEncoder.html">urlencode</a>，所以空格变成了<code>+</code>，<code>site:pan.baidu.com</code>变成了<code>site%3Apan.baidu.com</code>。</p>

<p>如果你不知道<code>urlencode</code>怎么做，可以先到Google上完成一次目标搜索，然后从地址栏上面复制下来。</p>

<p>定义好了自定义搜索引擎以后，你只需要在地址栏里面输入Keyword（panb），然后按<code>Tab</code>键，再输入你需要查找的资源，回车，就可以看到结果了。</p>

<p>具体使用过程请参考下面这个视频（略需要几秒加载）：</p>

<p><video width='640' height='320' preload='none' controls poster=''><source src='href="http://lenciel.com/downloads/video/chrome_custom_search.mp4">http://lenciel.com/downloads/video/chrome_custom_search.mp4</a>' ></video></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integrate schemaSpy with Sphinx build]]></title>
    <link href="http://lenciel.com/2014/12/integrate-schemaspy-with-sphinx-build-for-django-database-design-visualization/"/>
    <updated>2014-12-18T00:26:32+08:00</updated>
    <id>http://lenciel.com/2014/12/integrate-schemaspy-with-sphinx-build-for-django-database-design-visualization</id>
    <content type="html"><![CDATA[<p><img src="/downloads/images/2014_12/schemaSpy.png" title="schemaSpy..." alt="schemaSpy" /></p>

<p>在做项目的时候，客户或者合作的部门常常问研发要“数据库设计”。在古代，瀑布式开发的第一个阶段是做架构设计和写文档，所以这样的需求一般都能被“充分满足”。而在我们现在的项目节奏和迭代速度都很快，数据库的设计在项目初期经常也在变化，如何能够比较方便的文档化这些变更？</p>

<p>对开发团队内部来说，我个人觉得Django的South或者是1.7之后加入的<a href="http://lenciel.com/2014/08/django-1-dot-7-migrations/">Migration</a>里面每次变更生成的migration文件就已经足够开发人员了解底层的设计发生了什么变化。</p>

<p>而对外提供的文档，主要是在更高层级进行设计的沟通，所以之前我们一般是通过<a href="https://github.com/django-extensions/django-extensions">django-extension</a>里面的<code>graph_models</code>命令来生成简单的关系图：</p>

<pre><code class="bash"># Create a PNG image file called my_project_visualized.png with application grouping
$ ./manage.py graph_models -a -g -o my_project_visualized.png
</code></pre>

<p>效果如下：</p>

<p><img src="/downloads/images/2014_12/django_extension.svg" title="django-extension-sample..." alt="django-extension-sample" /></p>

<p>这里的图是通过<a href="http://www.graphviz.org/">graphviz</a>来完成的，可以看到一般的了解也足够了，但是缺点主要是：</p>

<ol>
<li>生成的关系图比较简陋</li>
<li>由于是图片，一旦表比较多浏览起来并不是那么灵活</li>
</ol>


<a name="L......schemaSpy"></a>
<h2>使用schemaSpy</h2>

<p>于是在新的项目里面本座选用了看起来更美好的<a href="http://schemaspy.sourceforge.net/">schemaSpy</a>，因为：</p>

<ol>
<li>轻量但支持多种数据库（jdbc），针对Django的test/stage/prod环境都可以使用</li>
<li><a href="http://schemaspy.sourceforge.net/sample/">功能非常强大</a>，并且有命令行支持，可以集成到CI</li>
</ol>


<p>不过和大多数开源工具一样，它的文档也是乱糟糟的。以开发环境为例，我们一般使用sqlite作为数据库，要在Mac下面成功运行schemaSpy连接sqlite，你需要：</p>

<ol>
<li>下载最新的<a href="http://sourceforge.net/projects/schemaspy/files/">SchemaSpy jar包</a></li>
<li>下载最新的<a href="https://bitbucket.org/xerial/sqlite-jdbc">Xerial Sqlite JDBC jar</a>包<code>sqlite-xerial.jar</code></li>
<li><p>创建一个<code>sqlite-xerial.properties</code>文件，内容如下：</p>

<pre><code class="`"> # Use -dp to override.
 description=SQLite
 connectionSpec=jdbc:sqlite:&lt;db&gt;
 db=database name
 driver=org.sqlite.JDBC
 #you may need to put the full path to the driver depending on your setup
 driverPath=sqlite-jdbc-3.8.7.jar
 selectTablesSql=.tables
</code></pre></li>
<li><p>运行命令：</p>

<pre><code class="`"> java -jar schemaSpy_5.0.0.jar -t  sqlite-xerial.properties -db ../src/default.db  -o django-testbird -sso
</code></pre></li>
</ol>


<p>会看到有<code>warning</code>，但是无需惊慌，我看了一下是schemaSpy的作者没有正确的处理<code>[]</code>。</p>

<a name="L.........Sphinx"></a>
<h2>集成到Sphinx</h2>

<p>因为我们的项目都使用了Jenkins自动启动Sphinx来生成文档，所以理想的情况当然是：</p>

<ol>
<li>修改Django下某个app的<code>models.py</code></li>
<li><code>make migration</code>生成migrations文件</li>
<li>代码提交并push到gitlab</li>
<li>Jenkins调用<code>django management command</code>完成表结构的变更</li>
<li>Jenkins自动更新包括数据库设计在内的文档</li>
</ol>


<p>要实现#5，最简单的办法是在Sphinx文档目录下的<code>Makefile</code>里面加一个<code>target</code>：</p>

<pre><code class="java">dbv:
    java -jar schemaSpy_5.0.0.jar -t sqlite-xerial.properties -db ../src/default.db  -o _db_virtualization/django-testproject -sso
</code></pre>

<p>然后在Jenkins调用的脚本里面加上<code>make dbv</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web应用开发的七项原则]]></title>
    <link href="http://lenciel.com/2014/11/7-principles-of-rich-web-applications/"/>
    <updated>2014-11-17T22:30:42+08:00</updated>
    <id>http://lenciel.com/2014/11/7-principles-of-rich-web-applications</id>
    <content type="html"><![CDATA[<p>本文源自Guillermo Rauch的<a href="http://rauchg.com/2014/7-principles-of-rich-web-applications/">7 Principles of Rich Web Application</a>，经过他本人授权，我翻译了放在这里。</p>

<p>这篇文章主要介绍构建使用Javascript来控制UI的网站在设计时的7个原则。它们是我作为一名开发人员的经验所得，也是我作为一名互联网资深用户的体会和总结。</p>

<p>Javascript毫无疑问早已成为了前端开发人员不可或缺的工具。但现在它的使用范围还在不断扩展到其他的领域，比如<a href="http://nodejs.org/">服务器端</a>甚至是<a href="https://tessel.io/">微控制器</a>。在斯坦福这样的声望卓越的大学里面，它也已经被选为计算机科学<a href="http://web.stanford.edu/class/cs101/">入门课程</a>的教学语言。 </p>

<p>即便如此，它在web开发中究竟应该扮演什么样的角色或者说负责哪方面的作用，仍然是个迷：即便对于很多框架和类库的作者而言也是如此：</p>

<ul>
<li>JavaScript应该被用来替代像<code>history</code>，<code>navigation</code>和<code>page rendering</code> 这样的浏览器函数么？</li>
<li>服务器端开发是不是到头了？是不是根本就不该在服务器端渲染HTML了？</li>
<li>Single Page Applications (SPAs) 是不是代表着未来的趋势?</li>
<li>一个网站和一个Web应用之间的区别精确的描述起来究竟是什么? 是不是应该就是一个东西?</li>
<li>在网站上，JS应该用来 <em>增强</em> 页面的效果，而在Web应用中，则被用来 <em>渲染</em> 整个页面?</li>
<li>是否应该使用像PJAX或者TurboLinks这样的技术?</li>
</ul>


<p>下面就是我试着回答这些问题做的一些分析。我的分析是通过用户体验(UX)层面，特别是如何最小化用户拿到他们感兴趣的 <em>数据</em> 的时间，作为切入点，来验证对Javascript的 <em>各种</em> 使用方式。我会从网络通信的基础入手，一直说到对未来趋势的预测。</p>

<ol>
<li><a href="#server-rendered-pages-are-not-optional">Server渲染页面仍然是必须的</a></li>
<li><a href="#act-immediately-on-user-input">对用户输入立刻响应</a></li>
<li><a href="#react-to-data-changes">数据变更时的应对</a></li>
<li><a href="#control-the-data-exchange-with-the-server">控制与服务器的数据交互</a></li>
<li><a href="#dont-break-history-enhance-it">不要破坏history，增强它</a></li>
<li><a href="#push-code-updates">推送代码更新</a></li>
<li><a href="#predict-behavior">行为预测</a></li>
</ol>


<a name="L1..Server...............................a.name..server-rendered-pages-are-not-optional....a."></a>
<h2>1. Server渲染页面仍然是必须的<a name="server-rendered-pages-are-not-optional"></a></h2>

<p><strong>TL;DR</strong>: <em>服务器端渲染与SEO无关，它主要的考虑是性能：需要考虑的包括不在服务器渲染的话，请求脚本、页面样式、页面资源和API请求造成的额外的开销，以及考虑在HTTP2.0里加入的<code>PUSH of resources</code></em>.</p>

<p>首先需要指出，在业界有一种错误的二分法："server-rendered apps" 和 &ldquo;single-page apps"的对立。如果我们的目标是用户体验和性能的最优化，那么选择其中任何一个而抛弃另一个都是错误的决定。原因其实很明显：整个互联网用于传输页面的介质，有一个理论上可计算的速度局限。关于这点，Stuart Cheshire有个著名的文献 (或者说是吐槽？)，<a href="http://rescomp.stanford.edu/~cheshire/rants/Latency.html">“It’s the latency, stupid”</a> :</p>

<p><blockquote><p>The distance from Stanford to Boston is 4320km.<br/>The speed of light in vacuum is 300 x 10<sup>6</sup> m/s.<br/>The speed of light in fibre is roughly 66% of the speed of light in vacuum.<br/>The speed of light in fibre is 300 x 10<sup>6</sup> m/s * 0.66 = 200 x 10<sup>6</sup> m/s.<br/>The one-way delay to Boston is 4320 km / 200 x 10<sup>6</sup> m/s = 21.6ms.<br/>The round-trip time to Boston and back is 43.2ms.<br/>The current ping time from Stanford to Boston over today’s Internet is about 85ms (…)<br/>So: the hardware of the Internet can currently achieve within a factor of two of the speed of light.</p></blockquote></p>

<p>这里提到的从波士顿到斯坦福路上花费的85ms，当然会随着时间的推移不断的改善：如果你现在测试一下说不定已经大大增速了。但需要注意很重要的一点：就算达到了光速，这两个海岸间最少也需要 <strong>50ms</strong> 才能完成通信。</p>

<p>换句话说，用户间连接的带宽再怎么显著提高，花在传输路上的延迟总有无法突破的速度极限。所以，在页面上显示信息时减少请求次数，也就是减少信息被传输在路上的次数，对于良好的用户体验和出色的响应速度而言，至关重要。</p>

<p>这一点在Javascript驱动的Web应用流行起来之后显得尤为明显。这些应用一般<code>&lt;body&gt;</code>标签内什么东西都没有，只有<code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>标签，被称为"Single Page Applications"或者"SPA"。就像它的名字所暗示的一样，服务器返回时一直在重用同一个页面，其他的页面内容都是在客户端被处理和渲染的。</p>

<p>考虑下面的这个场景：用户在浏览器上访问<code>http://app.com/orders/</code>，如果这是一个传统的网页，那么在后台处理这个请求的时，就会带回重要的 <em>信息</em> ，用来完成页面的显示：比如，从数据库里面查询出订单，然后把它们的数据放在请求的返回里面。但如果这是一个SPA，那么第一次可能会立刻返回一个包含<code>&lt;script&gt;</code>标签的空页面，然后再跑一趟才能拿回用来渲染页面的内容和数据。</p>

<p><img src="/downloads/images/2014_11/spa_code_breakdown.png" title="SPA code breakdown" alt="SPA code breakdown" />
图1. 服务器端发送的SPA的每个页面组成结构分析</p>

<p>目前大多数的开发者都大方接受了这个额外的 <em>网络传输过程</em> 是因为他们确信这只发生一次：后面反正是有cache的。也就是说，大家形成了这么一个共识，既然整个代码包一旦加载一次，就可以不用再请求其他的脚本和资源就完成对绝大多数的用户交互（包括跳转到应用的其他页面）的处理，那么这个开销就是可以接受的。</p>

<p>但实际上，虽然有cache，脚本解析和执行的时间仍然会带来性能上的下降。<a href="http://modernweb.com/2014/03/10/is-jquery-too-big-for-mobile/">“Is jQuery Too Big For Mobile?”</a> 这篇文章就探讨了即便是加载一个jQuery库，就会花去一些浏览器数百毫秒的时间。</p>

<p>更糟糕的是，和以前网速慢那种图片慢慢加载的效果不同，如果是脚本正在加载，用户什么都看不到：在整个页面被渲染出来之前，只能显示空白的页面。</p>

<p>最重要的是，目前互联网数据传输主要的协议TCP <em>建立</em> 比较慢。</p>

<p>首先，我们知道，一个TCP连接先需要握手。如果处于安全考虑使用了SSL，就还需要额外的两个来回（客户端重用了session的话，也需要一个额外的来回）。这些流程完毕之后，服务器才能开始往客户端发送数据。换句话说，再小的代码包实际上也需要几个来回才能完成传输，这就让前面描述的问题变得更加糟糕。</p>

<p>其次，TCP协议里面有一个流控机制，被称为 <code>slow start</code>，也就是在连接建立过程中逐渐增加传输的分段(<code>segments</code>)大小，入下图所示：</p>

<p><img src="/downloads/images/2014_11/tcp_segments_chart.png" title="TCP segments chart" alt="TCP segments chart" />
图2. 服务器端在TCP连接的不同阶段能够发送的分段大小(KB)</p>

<p>这对SPA有两个很大的影响：</p>

<ol>
<li><p>文件比较大的脚本，花在下载上的时间比你想象中的要长得多。Google的Ilya Grigorik在他的专著<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch02.html#thats_four_rou">“High Performance Browser Networking”</a> 里面说过，“4个来回(…)和数百毫秒的延迟都花在从服务器下载64KB的文件到客户端上了”，从前面的图也可以看到，基本是比较高速的网络连接，比如伦敦和纽约之间，一个TCP连接要达到最大速度，也需要花上大概225ms。</p></li>
<li><p>因为前面说的延迟对首个页面访问也是有效的，所以你让什么数据最先被传输就显得非常重要了。Paul Irish在他的演讲<a href="https://docs.google.com/presentation/d/1MtDBNTH1g7CZzhwlJ1raEJagA8qM3uoV7ta6i66bO2M/present#slide=id.g3eb97ca8f_10">“Delivering the Goods”</a>给出的结论是，一个Web应用最开始的 <strong>14kb</strong> 数据是最重要的。</p></li>
</ol>


<p>在足够短的时间窗内完成内容传输（哪怕只是呈现基本的没有数据的layout）的网站，就是响应良好的。这也是为什么对于很多习惯了在服务器端处理数据的软件开发者觉得Javascript很多时候根本没必要用，或者是在很有限的情况下用用就行了。当这些开发者使用的是配置良好的服务器和数据库，又有CDN来做部署和分发时，他们这种感觉会非常明显。</p>

<p>但是，服务器在辅助和加速页面内容的分发和渲染中应该被怎么使用，也是需要根据每个应用场景仔细分析的，绝对不是“把整个页面交给服务器渲染吧”那么简单的事情。在一些情况下，如果页面上的内容对用户并不是非看不可的，就可以不放在第一个响应中返回，而是让客户端在后面的操作中到服务器去取。</p>

<p>比如，有的应用会先把一个"壳"页面返回给客户端，然后在这个页面上并发的请求多个部分的数据。这样即使在后台连接速度较慢的情况下，仍然能够有较好的响应速度。还有的应用会把 “<a href="http://www.feedthebot.com/pagespeed/prioritize-visible-content.html">浏览器里面的第一个整屏</a>” 显示的页面做预渲染。</p>

<p>服务器能够根据当前处理的<code>session</code>，用户和URL对脚本和样式文件进行分类也是很重要的。举例来说，用来对订单进行分类的脚本，对于<code>/orders</code>这个URL显然是重要的，而处理"首选项"的逻辑的脚本就不那么重要。再比如说，我们可以对CSS样式表进行分类，比如区分“结构性的样式”和“皮肤和模板的样式”等。前面这类很可能对Javascript的正确运行是必须的，因此需要 <em>阻塞</em> 的方式加载， 后面这类则可以用异步的方式加载。</p>

<p>到目前为止，在服务器端处理一部分或者所有的页面，仍然是避免过多客户端与服务器的交互的主要手段。<a href="http://danlec.com/blog/stackoverflow-in-4096-bytes">StackOverflow in 4096 bytes</a>很不错地展示了如何降低和服务器的来回交互次数。作为概念验证的SPA，它理论上可以做到在握手后的第一个TCP连接中完成加载！当然，要做到这些，它使用了<a href="http://www.chromium.org/spdy/link-headers-and-server-hint">SPDY 或者 HTTP/2 server push</a>，因此可以在一个hop里面传输所有客户端可以缓存的代码。</p>

<p><img src="/downloads/images/2014_11/st4k.png" title="StackOverflow clone in 4096 bytes" alt="StackOverflow clone in 4096 bytes" /></p>

<p>图3. 使用了内链CSS和JS技术的<code>Stackoverflow in 4096 bytes</code></p>

<p>如果我们有一个足够灵活的系统，可以在浏览器和服务器直接共享渲染页面的代码（比如双方都是js），并且提供工具增量的加载脚本和样式，那么 <em>网站</em> 和 <em>Web应用</em> 就可以合一而不再是两个模棱两可难以区分的词了：它们本身就有一样的UX要素。比如一个博客页面和一个复杂的CRM，都有URL，都需要跳转，都展示数据，本质上并没有太大不同。即便是像数据表格这样复杂的东西，传统上主要是客户端提供的功能来完成对数据的处理，但也首先需要给用户展示那些需要他处理的数据 。降低客户端和服务器交互的次数，对实现我们说的这样的系统非常重要。</p>

<p>在我看来，我们看到的大量系统上采用了这样那样性能上的权宜之策，是因为整个技术栈的复杂度在不断累加。Javascript和CSS这样的技术是被逐渐加入到系统的，它们的风靡又花了一段时间。尽管有人希望在协议上做出改进，来增强性能（比如SPDY或者QUIC），但应用层显然才是最需要改进的地方。</p>

<p>要理解速度的重要性，去重温一下WWW和HTML创立之初的一些讨论是非常有用的。特别是在1997年提议在HTML里加入<code>img</code>这个标签的时候，Marc Andreessen在<a href="http://1997.webhistory.org/www.lists/www-talk.1993q1/0260.html">下面这个邮件thread</a>里反复强调了提供信息的速度有多么重要： </p>

<p><blockquote><p>“If a document has to be pieced together on the fly, it could get arbitrarily complex, and even if that were limited, we’d certainly start experiencing major hits on performance for documents structured in this way. This essentially throws the <strong>single-hop principle of WWW</strong> out the door (well, IMG does that too, but for a very specific reason and in a very limited sense) — are we sure we want to do that?”</p></blockquote></p>

<a name="L2..............................a.name..act-immediately-on-user-input....a."></a>
<h2>2. 对用户输入立刻响应<a name="act-immediately-on-user-input"></a></h2>

<p><strong>TL;DR</strong>: <em>我们可以使用JavaScript来掩盖网络的延迟，把它作为设计原则，就可以在你自己的应用里面去掉绝大多数的<code>spinner</code>或者<code>loading</code>。使用PJAX和TurboLink的话，你就会失去了这些改善用户速度体验的机会。</em>.</p>

<p>第一个原则里，在描述为什么要尽量减少前端和后端之间数据来回传输的次数时，主要是基于传输速度有理论上限的事实。实际上另一个需要考虑的要素就是网络的质量。我们都知道，当网络连接状况不好时，就会有数据包需要被重传。所以，你觉得应该一个来回就传输完毕的数据，可能实际上要花去好几个。</p>

<p>在这方面，Javascript正好可以帮上忙：通过客户端的代码来驱动UI，人工的构造出零延迟，就可以<em>掩盖网络的延迟</em>，制造一切操作都很顺畅的假象。比如，网页和网页之间是通过超链接，<code>&lt;a&gt;</code>标签，链接在一起的。传统网页上，当一个链接被点击时，浏览器就发送一个可能会耗时很久的请求，然后处理请求并把内容呈现给用户。</p>

<p>但Javascript允许你<strong>立刻响应</strong>（有些地方把这个叫<strong>乐观响应</strong>）：当一个链接或者按钮被点击时，页面立刻做出响应而不需要去访问网络。这方面著名的例子就是Gmail（包括最近Google的新产品Inbox）的"邮件归档"功能。当你点击"归档"，UI上邮件立刻会被显示为归档状态，而服务器的请求和处理是异步进行的。</p>

<p>再比如，我们处理的是一个表单。也许你觉得一个表单在数据被提交到服务器，处理结果返回之前，不能做太多的事情。但其实当用户完成输入并点击提交的时候，我们就可以开始响应了。甚至有些做到极致的应用，比如Google搜索页面，当用户开始输入的时候，展示搜索结果的页面就已经开始渲染了。</p>

<p><img src="/downloads/images/2014_11/google_homepage.gif" title="Google Homepage" alt="Google Homepage" /></p>

<p>图4. Google在用户输入搜素关键字时就开始渲染搜索结果页面</p>

<p>这种行为被称为 <em>layout adaptation</em>。 它的思路是当前页面知道操作后状态的页面layout，所以在没有数据填充的情况下，它就可以过渡到下面那个状态的layout。这样的处理是"乐观"的，是因为有可能后面那个页面的数据一直没有返回，而这时候页面的layout已经画在那里了。</p>

<p>Google的主页的演进，非常清楚的说明了我们这里强调的第一和第二个原则。</p>

<p>首先，分析访问<code>www.google.com</code>时TCP连接的<a href="https://gist.github.com/guille/3e1b2d7529009370b986">包数据</a>可以看到整个首页的数据都被一次性发出来了。整个交互，包括关闭连接，耗时几十毫秒而已。而且，似乎在Google<a href="http://en.wikipedia.org/wiki/Google#mediaviewer/File:Google1998.png">一开始的版本</a>就做到了这点。</p>

<p>在2004年晚些时候, Google<a href="http://googleblog.blogspot.com/2004/12/ive-got-suggestion.html">标杆性地</a>使用了JavaScript完成<code>输入时动态提示</code>功能（和Gmail一样，也是一个20%创新时间产出的项目），这一功能也启发了很多网站开始大量的使用<a href="http://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/">AJAX</a>:</p>

<p><blockquote><p>Take a look at Google Suggest. Watch the way the suggested terms update as you type, almost instantly with no waiting for pages to reload. Google Suggest and Google Maps are two examples of a new approach to web applications that we at Adaptive Path have been calling Ajax</p></blockquote></p>

<p>到了2010年，Google又<a href="http://googleblog.blogspot.com/2010/09/search-now-faster-than-speed-of-type.html">推出了</a><em>及时搜索</em>，也就是我们前面看到的效果：当用户输入关键字时，整个页面无需刷新就可以展示搜索的结果。</p>

<p>另一个例子是iOS。在很早期的版本，iPhone就要求开发者提供一个<code>default.png</code>图片，用来在应用被加载完成之前显示给用户:</p>

<p><img src="/downloads/images/2014_11/iphone_default_png.png" title="iPhone default" alt="iPhone default" /></p>

<p>图5. iPhone OS强制在应用加载前显示一个default.png</p>

<p>当然，这里OS不是在隐藏网络延迟，而是CPU处理延迟。对于iPhone初期版本来说，这样来弥补硬件的弱点非常重要。当然就和网页上使用提前加载一样，这种手法有可能会崩坏：当加载来的数据和<code>default.png</code>不匹配的时候。Marco Arment在2010年对它可能带来的影响进行了 <a href="http://www.marco.org/2010/11/11/my-default-png-dilemma">透彻的分析</a>。</p>

<p>除开处理表单和输入，Javascript还被大量用于处理<strong>文件上传</strong>。我们可以通过各种前端表现来满足用户上传文件的需求：拖拽，粘贴以及各种file picker。特别是有了<a href="https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications">HTML5的新API</a>之后，我们可以在文件完成传输前就显示它的信息。在Cloudup网站的上传文件中，就使用了类似的实现。从图片中可以看到，在用户选择了文件之后，缩略图就立刻生成并显示在用户界面上了：</p>

<p><img src="/downloads/images/2014_11/cldup_upload.gif" title="Cloudup upload" alt="Cloudup upload" /></p>

<p>图6. 在上传完成前图片就被显示出来并且加入了虚化效果</p>

<p>上面的方式都是采用前端技术来制造<em>速度的假象</em>，但这种方式其实在很多地方都被证明是有效的。<a href="http://www.nytimes.com/2012/08/19/opinion/sunday/why-waiting-in-line-is-torture.html">一个例子</a>是在美国休斯顿机场，通过<em>增加</em>到达乘客走到行李提取处的距离，而不是实际上的行李处理速度，就大大的<em>减少</em>了旅客抱怨行李领取太慢的问题。</p>

<p>运用了这种设计原则的应用，使用<code>spinners</code>或者<code>loading</code>提示符来提醒用户页面正在刷新的场景会非常少出现。整个页面的动线，都应该被<em>实际数据</em>来驱动。</p>

<p>当然，立即响应这个原则也不能被滥用。在特定的用户交互场景下，立即响应是有害的：比如用户在注销或者是支付的流程中，我们当然不能让他"乐观"的认为没有真正完成的操作已经完成了。但即使在这些场景下，使用<code>spinners</code>或者<code>loading</code>提示符也不应该<strong>被提倡</strong>。 只有在你觉得应该提醒用户这个操作会非常长，你可以去干别的事情时，才应该显示它们。那是多长？在UX设计中经常被引用的<a href="http://www.nngroup.com/articles/response-times-3-important-limits/">Nielsen的研究报告</a>上是这么说的：</p>

<p><blockquote><p>The basic advice regarding response times has been about the same for thirty years Miller 1968; Card et al. 1991:<br/>0.1 second is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.<br/>1.0 second is about the limit for the user’s flow of thought to stay uninterrupted, even though the user will notice the delay.Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.<br/>10 seconds is about the limit for keeping the user’s attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish.</p></blockquote></p>

<p>像PJAX或者TurboLinks这样的技术，则很大程度上完全不具备提前渲染状态迁移后下一个页面的基础layout的能力。只有当服务器端的返回传输到客户端，客户端才能开始响应。</p>

<a name="L3...........................a.name..react-to-data-changes....a."></a>
<h2>3. 数据变更时的应对<a name="react-to-data-changes"></a></h2>

<p><strong>TL;DR</strong>: <em>当服务器的数据变化时，应该主动让用户知道。这样可以使得用户无需经常进行手动的刷新(F5, Cmd+R&hellip;.)，也是一种性能上的改进措施。新的挑战是：(重)连接的管理，状态的一致性问题</em>.</p>

<p>第三个原则就是当数据源(一般是一个或者多个数据库)的数据有变更时，UI要<em>主动响应</em>。</p>

<p>给用户一个当前数据的静态的HTML快照，直到用户刷新页面（传统网页）或者操作页面元素（AJAX）已经逐渐变得过时。你的UI应该是<strong>自刷新</strong>的。当数据节点不断增加，我们设计时需要开始考虑包含手表、电话的各种移动设备和可穿戴设备时，这点尤其重要。</p>

<p>以Facebook初期对newsfeed的实现为例，因为用户都是用PC机在更新状态，把它实现成静态的网页未尝不可：一般来说，人们一天更新一次就差不多了。但现在我们生活在一个人们拍照后可以立刻分享，朋友们可以立刻发表评论的时代，对数据变化的实时响应成为了应用开发的基础需求。这不仅仅是因为我们的应用程序是多用户并发访问的，即便就考虑单用户的场景，实时更新也是很重要的。以用笔记本分享我们手机上的照片的场景为例：</p>

<p><img src="/downloads/images/2014_11/concurrent_data_points.gif" title="Concurrent Data Points" alt="Concurrent Data Points" /></p>

<p>图7. 即便是单个用户操作的场景，更好的响应性也能带来体验的提升</p>

<p>有的数据，比如<strong>Session和登录状态的同步</strong>，在多个页面间应该是非常实时的同步的。这样，当用户打开了多个tab，从其中的任何一个登出，其他的所有页面都应该登出。这点对保护用户的隐私是非常重要的，特别是我们有些设备是多个人在同时使用。</p>

<p><img src="/downloads/images/2014_11/login_sync.gif" title="Login synchronization" alt="Each page reacts to the session and login state" /></p>

<p>图8. 不同的页面间同步登录状态</p>

<p>一旦你的用户习惯了你的应用的数据是自动更新的，那么你就要考虑一个新的需求：<strong>状态一致性</strong>。当客户端收到一个原子的数据更新时，必须考虑即便在断网很长时间之后，也能够正确的完成更新。比如，你的笔记本突然没电了，几天后再打开，应用的数据是不是还正确？</p>

<p><img src="/downloads/images/2014_11/twitter_data_reconciliation.png" title="twitter数据一致性" alt="twitter数据一致性" /></p>

<p>图9. 长时间断线后重连的情况下twitter的页面</p>

<p>是不是能够保持数据的一致性也会影响你的应用在第一条原则上的表现。如果你想对首次请求的数据做优化，必须要考虑如果是断线后重连，那么第一个请求应该首先需要重新建立session。</p>

<a name="L4....................................a.name..control-the-data-exchange-with-the-server....a."></a>
<h2>4. 控制与服务器的数据交互<a name="control-the-data-exchange-with-the-server"></a></h2>

<p><strong>TL;DR</strong>: <em>接下来主要讨论的是如何精细的控制客户端和服务器之间的交互。注意出错处理，自动重试，在后台同步数据并管理好离线的缓存。</em></p>

<p>在互联网初期，客户端和服务器间的交互还仅仅有下面几种方式:</p>

<ol>
<li>点击一个连接，会触发 <code>GET</code> 来获取一个新页面并重新渲染页面</li>
<li>提交一个表单，会触发一个 <code>POST</code> 或 <code>GET</code> 并重新渲染页面</li>
<li>嵌入一个图片或者对象，会触发一个异步的 <code>GET</code> 并重新渲染页面</li>
</ol>


<p>这个模型以其简洁性显得很具吸引力，但是我们今天要明白服务器和客户端之间的数据交互，学习曲线就陡多了。最大的问题在第二点，如果不能在不刷新页面的情况下提交数据，毫无疑问是一个性能上的弱点。更重要的是，它会使得回退键不可用：</p>

<p><img src="/downloads/images/2014_11/annoy_artifact.png" title="Annoy Artifact" alt="Possibly the most annoying artifact of the old web" /></p>

<p>图10. 老一代网页上最让人讨厌的东西</p>

<p>把网站作为<strong>应用平台</strong> 来考虑，没有Javascript将是不可想象的事情。AJAX单单是在表单信息提交这方面，就让交互体验产生了一次<em>飞跃</em>。我们现在更是有了一堆各式各样的API (<code>XMLHttpRequest</code>, <code>WebSocket</code>, <code>EventSource</code>以及更多其他的) 来更好地更细致的控制数据流。不但可以在用户输入的时候就开始处理用户数据，还能够有机会提供更好的UX体验。其中一个和前面那个原则有关的UX体验上的改进就是显示当前<em>连接状态</em>。如果我们的用户觉得数据是应用自己去刷新不需要他手动操作，那么就应该显示<em>连接中断</em>以及<em>正在重试连接中&hellip;</em>等状态。</p>

<p>当发生连接中断时，最好先把数据存在内存（或者更好的，存到<code>localStorage</code>），以便在网络恢复后重新发送。 就像在<a href="http://jakearchibald.com/2014/using-serviceworker-today/">ServiceWorker</a>的介绍中提到的那样, 可以让Javascript应用在<em>后台运行</em>。</p>

<p>除开断网，当发送数据出现超时或者是错误时，也可以试着<strong>自动重试</strong>，只在确认无法成功了之后，才将问题抛给用户感知。当然，有些特别的错误还是需要额外小心的处理。比如一个<code>403</code>错误，通常说明用户的session过期了。这种情况下就该让用户重新登录，而不是继续重试了。</p>

<p>还要注意使用这种模式时，要屏蔽用户中断数据流的操作。这种操作有两种，第一种也是最明显的一种是用户尝试关闭当前页面，这种情况可以通过<code>beforeunload</code>这个<code>handler</code>来处理。</p>

<p><img src="/downloads/images/2014_11/before_unload_warning.png" title="Before unload warning" alt="The beforeunload browser warning" /></p>

<p>图11. 页面关闭之前弹出警告</p>

<p>另一种（不那么明显的）是那些触发页面转换的操作。比如点击页面上的链接，触发一个新的页面载入。这种时候你可以显示自己的弹出窗口。</p>

<a name="L5..............history.............a.name..dont-break-history-enhance-it....a."></a>
<h2>5. 不要破坏history，增强它<a name="dont-break-history-enhance-it"></a></h2>

<p><strong>TL;DR</strong>: <em>不使用浏览器来管理URL跳转和history，将带来新的挑战。我们必须保证用户在浏览时，应用的表现符合他的期望。可以自建缓存来提高响应速度。</em></p>

<p>即使不考虑表单的提交，而是设计一个仅有超链接的Web应用，也需要考虑让前进/后退导航变得更可用。比如典型的<code>infinite pagination scenario</code>，也就是应用应该允许用户在页面上随便跳转，它的实现通常需要使用Javascript监听对链接的点击，然后注入数据或者HTML（还有个可选的步骤是调用<code>history.pushState</code>或者是<code>replaceState</code>，但不幸的是很多人都不没有使用它们）。</p>

<p>这就是我使用“破坏”来形容它的原因：在Web被设计之初，这种监听对链接的点击并注入数据的情况，并不在设计图景中，而是每个状态的变迁都需要URL的变化来驱动。但虽然这种既有模式被Javascript“破坏”了，另一方面，通过使用Javascript控制history，也出现了<em>提升</em>的机会。</p>

<p>一种提升的做法是Daniel Pipius提出的所谓<a href="https://medium.com/joys-of-javascript/beyond-pushstate-building-single-page-applications-4353246f4480">Fast Back</a>:</p>

<blockquote><p>回退应该很快；用户默认数据不会有很大的变化，应该能很快回到上个页面。</p></blockquote>

<p>我们可以近似的把回退按钮认为是一个在应用每个页面都可用的按钮，然后使用原则2来设计它：<em>对用户输入立刻响应</em>。这里要考虑的关键就变成了如何缓存前一个页面以便很快能再次渲染出来。接下来你就还可以想想原则3：如何在数据有了变化时，让用户感知到这些变化。</p>

<p>另外，有一些场景下，你没法控制缓存的行为。比如，如果用户在你渲染一个页面的时候跳到第三方网站上去了，然后他按回退键。这个时候就会遇到下面的这个bug：</p>

<p><img src="/downloads/images/2014_11/back_button_bug.gif" title="Back Button Bug" alt="Pressing back incorrectly loads the initial HTML from the pageload" />
图12. 按回退键时载入了原始页面的HTML而不是刷新后的</p>

<p>另一种破坏性的操作是忽略 <em>scrolling memory</em>。和之前那个问题一样，如果页面没有JS或者其他人工的history管理，多半就不会有这个问题。但局部动态刷新的页面多半就会遇到：我测试了最著名的Javascript驱动的网站，它们的newsfeeds都有<em>scrolling amnesia</em>的问题：</p>

<p><img src="/downloads/images/2014_11/back_button_bug.gif" title="Scrolling Amnesia" alt="Infinite pagination is usually susceptible to scrolling amnesia" /></p>

<p>图13. 滚动失忆问题</p>

<p>最后，要注意哪些状态应该被持久化。比如是不是需要展开显示文章的评论：</p>

<p><img src="/downloads/images/2014_11/back_button_bug.gif" title="Scrolling Amnesia" alt="Infinite pagination is usually susceptible to scrolling amnesia" /></p>

<p>图14. 在操作history来导航时，是否展开显示评论也被持久化了</p>

<p>因为是在应用内使用超链接触发的页面重渲染，用户的期望是回到这页时，他之前展开的评论树仍然是展开的。这个状态其实是<em>瞬态的</em>， 仅仅在history栈上的这页有这个状态。</p>

<a name="L6.....................a.name..push-code-updates....a."></a>
<h2>6. 推送代码更新<a name="push-code-updates"></a></h2>

<p><strong>TL;DR</strong>: <em>数据自动更新但代码的更新不是自动推送的应用是低效的。要避免API出错，增强性能。使用无状态的DOM来避免重画。</em></p>

<p>让你的应用能够对<em>代码变更</em>进行推送是至关重要的。</p>

<p>首先，这样可以减少出错的可能并增强稳定性。当你的后台接口改变时，客户端的变更是<em>必须的</em>，否则客户端就没法处理服务器来的新格式的数据，或者上报一堆服务器没法理解的旧格式的数据。</p>

<p>考虑到原则3，代码更新的推送还有一个重要的原因：传统的网站，刷新页面一方面是为了加载新的数据，另一方面也常常是为了加载新的代码。一旦你的UI让用户觉得数据是自动刷新的，他们就不会有意识的再去刷新页面。这样仅仅有一套数据推送的机制是不够的，特别是考虑到现今很多应用一个页面要被打开很长的时间。</p>

<p>如果服务器本身有notification通道，那么可以在代码需要更新的时候推送通知给用户。如果没有，可以在客户端请求的HTTP头里面带一个版本号。服务器检查这个版本号，根据情况看要不要拒绝客户端的请求并要求它更新。</p>

<p>有了这些，应用就可以在加载数据或者代码时不再需要用户自主进行页面刷新了。比如，当一个页面<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API">不可见</a>，表单的输入没有被填写的时候。</p>

<p>但更好的做法是进行所谓的<strong>代码热重载</strong>。 这主要是指整个页面不需要进行重刷，而是特定的<em>模块</em>被替换并重新执行代码逻辑。</p>

<p>在很多已有的代码基础上要实现代码热重载是困难的。但从架构上把<em>行为</em>（代码）和<em>数据</em>（状态）隔离，也是非常值得考虑和探讨的。如果能这样解耦，就能很轻松的进行很多本来复杂的修改。</p>

<p>比如，你的应用需要建立一个事件总线（比如<a href="http://socket.io/">socket.io</a>）。当总线接收到事件时，某个特定的模块就改变自己的行为，比如，根据新的数据状态来产生不同的DOM内容。</p>

<p>理想状态下，我们能够以单个模块的粒度来更新代码。也就是说，仅仅因为要更新代码，没必要断开现有的socket连接。这样理想的代码能够热重载的架构就是<em>模块化</em>的。但是这里带来的挑战是模块的更新不能带来意料之外的副作用，为了实现这点，像<a href="http://facebook.github.io/react/">React</a>这样的优秀的框架被创造出来。当一个模块的代码更新后，它的代码逻辑能够静静地重新运行一次来更新DOM。 这方面的一些解释可以看看Dan Abramov的<a href="http://gaearon.github.io/react-hot-loader/">文章</a>.</p>

<p>从根本上来说，代码热重载可以极大程度上帮助你基于DOM渲染页面。特别是当状态保持在DOM里面，或者是事件响应都是你自己手工创建的时候，更新代码是一个非常复杂的事情。</p>

<a name="L7...............a.name..predict-behavior....a."></a>
<h2>7. 行为预测<a name="predict-behavior"></a></h2>

<p><strong>TL;DR</strong>: <em>通过行为预测来进一步减少延迟。</em></p>

<p>一个Javascript的应用可以有预测<em>用户输入</em>的机制。</p>

<p>最常见的办法是在数据请求的动作被真正触发之前就进行数据的预获取。比如在用户hover到链接上而不是真正点击链接的时候就开始取数据。</p>

<p>另一个比较复杂的预测用户行为的办法是通过监听用户鼠标的运动，分析它的轨迹来预测它可能会去到的”可以操作元素“，比如是按钮。下面是一个<a href="https://medium.com/@cihadturhan/a-ux-idea-i-know-where-you-are-aiming-3e00d152afb2">jQuery的例子</a>:</p>

<p><img src="/downloads/images/2014_11/behavior_predict.gif" title="I know where you're aiming" alt="jQuery plugin that predicts the mouse trajectory" /></p>

<p>图12. jQuery鼠标运动轨迹预测插件</p>

<a name="L.......a.name..conclusion....a."></a>
<h2>结论<a name="conclusion"></a></h2>

<p>网络过去和现在都是信息传递最通用的媒介。当我们不断让我们的页面变得更动态时，也要注意在引入新的特性时，能保持历史上确定的一些好的用户体验准则。</p>

<p>互相用超链接集结在一起的页面是各种类型的应用的组成单位。当用户浏览页面时，渐进地加载代码、样式表和标记，可以在保证性能的基础上不牺牲太多的交互性。</p>

<p>Javascript带来了新的契机，一旦被全面采用，将可以在保证最佳的用户体验基础上，构建前所未有的最广阔最开放的应用平台。</p>
]]></content>
  </entry>
  
</feed>
